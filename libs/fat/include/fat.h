#pragma once
#ifndef FAT_H
#define FAT_H

#include <stdint.h>

/*
	FAT specification:
	https://academy.cba.mit.edu/classes/networking_communications/SD/FAT.pdf
*/

// #define FAT_BPB_MEDIA_E5			0xe5
// #define FAT_BPB_MEDIA_ED			0xed
// #define FAT_BPB_MEDIA_EE			0xee
// #define FAT_BPB_MEDIA_EF			0xef

/**
 * - 3.5-inch (90 mm) double sided, 80 tracks per side, 18 or 36 sectors per track (1440 KB, known as "1.44 MB"; or 2880 KB, known as "2.88 MB").
 * - Designated for use with custom floppy and superfloppy formats where the geometry is defined in the BPB.
 * - Used also for other media types such as tapes
 */
#define FAT_BPB_MEDIA_F0			0xf0
// #define FAT_BPB_MEDIA_F4			0xf4
// #define FAT_BPB_MEDIA_F5			0xf5

/**
 * - Fixed disk (i.e., typically a partition on a hard disk). (since DOS 2.0)
 * - Designated to be used for any partitioned fixed or removable media, where the geometry is defined in the BPB.
 * - 3.5-inch single sided, 80 tracks per side, 9 sectors per track (360 KB) (MS-DOS 3.1 and MSX-DOS)
 */
#define FAT_BPB_MEDIA_F8			0xf8

/**
 * - 3.5-inch double sided, 80 tracks per side, 9 sectors per track (720 KB) (since DOS 3.2)
 * - 3.5-inch double sided, 80 tracks per side, 18 sectors per track (1440 KB) (DOS 3.2 only)
 * - 5.25-inch double sided, 80 tracks per side, 15 sectors per track (1200 KB, known as "1.2 MB") (since DOS 3.0)
 */
#define FAT_BPB_MEDIA_F9			0xf9

/**
 * - 3.5-inch and 5.25-inch single sided, 80 tracks per side, 8 sectors per track (320 KB)
 * - Used also for RAM disks and ROM disks (e.g., on Columbia Data Products and on HP 200LX)
*/
#define FAT_BPB_MEDIA_FA			0xfa

/**
 * - 3.5-inch and 5.25-inch double sided, 80 tracks per side, 8 sectors per track (640 KB)
 */
#define FAT_BPB_MEDIA_FB			0xfb

/**
 * - 5.25-inch single sided, 40 tracks per side, 9 sectors per track (180 KB) (since DOS 2.0)
 */
#define FAT_BPB_MEDIA_FC			0xfc

/**
 * - 5.25-inch double sided, 40 tracks per side, 9 sectors per track (360 KB) (since DOS 2.0)
 * - 8-inch double sided, 77 tracks per side, 26 sectors per track, 128 bytes per sector (500.5 KB)
 * - 8-inch double sided, (single and) double density (DOS 1)
 */
#define FAT_BPB_MEDIA_FD			0xfd

/**
 * - 5.25-inch single sided, 40 tracks per side, 8 sectors per track (160 KB) (since DOS 1.0)
 * - 8-inch single sided, 77 tracks per side, 26 sectors per track, 128 bytes per sector (250.25 KB)
 * - 8-inch double sided, 77 tracks per side, 8 sectors per track, 1024 bytes per sector (1232 KB)
 * - 8-inch single sided, (single and) double density (DOS 1)
 */
#define FAT_BPB_MEDIA_FE			0xfe

/**
 * - 5.25-inch double sided, 40 tracks per side, 8 sectors per track (320 KB) (since DOS 1.1)
 */
#define FAT_BPB_MEDIA_FF			0xff

#define FAT_ATTR_READ_ONLY			0x01
#define FAT_ATTR_HIDDEN				0x02
#define FAT_ATTR_SYSTEM				0x04
#define FAT_ATTR_VOLUME_ID			0x08
#define FAT_ATTR_DIRECTORY			0x10
#define FAT_ATTR_ARCHIVE			0x20
#define FAT_ATTR_LONG_NAME			(FAT_ATTR_READ_ONLY | FAT_ATTR_HIDDEN | FAT_ATTR_SYSTEM | FAT_ATTR_VOLUME_ID) 

#pragma pack(push, 1)
typedef struct _fat_bpb_t {
	uint8_t		BS_jmpBoot[3];			// jump instruction to boot code
	char		BS_OEMName[8];			// can be set by a FAT implementation to any desired value. 
	uint16_t	BPB_BytsPerSec;			// count of bytes per sector: 512/1024/2048/4096
	uint8_t		BPB_SecPerClus;			// number of sectors per allocation unit: 1/2/4/8/16/32/64/128
	uint16_t	BPB_RsvdSecCnt;			// number of reserved sectors
	uint8_t		BPB_NumFATs;			// count of FATs on the volume
	uint16_t	BPB_RootEntCnt;			/** @warning 0 if it's FAT32 */
	uint16_t	BPB_TotSec16;			// this field can be 0; if it is 0, then BPB_TotSec32 must be non-zero. For FAT32 volumes, this field must be 0. 
	
	/**
	 * legal values: 0xf0, 0xf8-0xff
	 * - 0xf0 - removable media
	 * - 0xf8 - fixed (non-removable) media
	 */
	uint8_t		BPB_Media;
	uint16_t	BPB_FATSz16;			/** @warning 0 if it's FAT32 */
	uint16_t	BPB_SecPerTrk;
	uint16_t	BPB_NumHeads;
	uint32_t	BPB_HiddSec;
	uint32_t	BPB_TotSec32;
} fat_bpb_t;

typedef struct _fat_ebpb16_t {
	uint8_t		BS_DrvNum;
	uint8_t		BS_Reserved1;

	/**
	 * - 0x28 if both following fields are zero
	 * - 0x29 if either of the following two fields are non-zero
	 */
	uint8_t		BS_BootSig;

	/*
		This ID should be generated by simply combining
		the current date and time into a 32-bit value.
	*/
	uint32_t	BS_VolID;

	/**
	 * @note FAT file system drivers must ensure
	 * that they update this field when the volume
	 * label file in the root directory has its name
	 * changed or created. The setting for this
	 * field when there is no volume label is the string "NO NAME    "
	 */
	char		BS_VolLab[11];

	/**
	 * "FAT12   "/"FAT16   "/"FAT32   "
	 * @note this string is informational only and
	 * does not determine the FAT type
	 */
	char		BS_FilSysType[8];
	uint8_t		BootCode[448];
	uint16_t	Signature_word;			// { 0x55, 0xaa }
} fat_ebpb12_t, fat_ebpb16_t;

typedef struct _fat_ebpb32_t {
	uint32_t	BPB_FATSz32;
	uint16_t	BPB_ExtFlags;
	uint16_t	BPB_FSVer;
	uint32_t	BPB_RootClus;
	uint16_t	BPB_FSInfo;

	/**
	 * 0 or 6
	 * - 0 - no backup boot sector
	 * - 6 - copy of the boot record
	 */
	uint16_t	BPB_BkBootSec;
	uint8_t		BPB_Reserved[12];

	uint8_t		BS_DrvNum;
	uint8_t		BS_Reserved1;

	/**
	 * - 0x28 if both following fields are zero
	 * - 0x29 if either of the following two fields are non-zero
	 */
	uint8_t		BS_BootSig;

	/*
		This ID should be generated by simply combining
		the current date and time into a 32-bit value.
	*/
	uint32_t	BS_VolID;

	/**
	 * @note FAT file system drivers must ensure
	 * that they update this field when the volume
	 * label file in the root directory has its name
	 * changed or created. The setting for this
	 * field when there is no volume label is the string "NO NAME    "
	 */
	char		BS_VolLab[11];

	/**
	 * "FAT12   "/"FAT16   "/"FAT32   "
	 * @note this string is informational only and
	 * does not determine the FAT type
	 */
	char		BS_FilSysType[8];
	uint8_t		BootCode[420];
	uint16_t	Signature_word;			// { 0x55, 0xaa }
} fat_ebpb32_t;

typedef struct _fat_fsinfo_t {
	uint32_t	FSI_LeadSig;			// 0x41615252
	uint8_t		FSI_Reserved1[480];
	uint32_t	FSI_StrucSig;			// 0x61417272
	uint32_t	FSI_Free_Count;			// - 0xFFFFFFFF - not known
	uint32_t	FSI_Nxt_Free;			// - 0xFFFFFFFF - not known
	uint8_t		FSI_Reserved2[12];
	uint32_t	FSI_TrailSig;			// 0xAA550000
} fat_fsinfo_t;

typedef struct _fat_dir_t {
	/**
	 * Short File Name (8.3 format)
	 * - DIR_Name[0] == 0xe5 => directory entry is free
	 * - DIR_Name[0] == 0x00 => directory entry is free &
	 * all directory entries following the current free
	 * entry are also free
	 */
	char		DIR_Name[11];
	uint8_t		DIR_Attr;				// FAT_ATTR_...
	uint8_t		DIR_NTRes;				// 0
	uint8_t		DIR_CrtTimeTenth;		// from 0 to 199
	uint16_t	DIR_CrtTime;
	uint16_t	DIR_CrtDate;
	uint16_t	DIR_LstAccDate;
	uint16_t	DIR_FstClusHi;
	uint16_t	DIR_WrtTime;
	uint16_t	DIR_WrtDate;
	uint16_t	DIR_FstClusLo;
	uint32_t	DIR_FileSize;
} fat_dir_t;
#pragma pack(pop)

int t = 36 + sizeof(fat_fsinfo_t);

#endif